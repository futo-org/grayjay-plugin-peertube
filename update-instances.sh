#!/bin/sh

# This script updates PeerTube instances by:
# 1. Fetching new instances from https://instances.joinpeertube.org/api/v1/instances/hosts
# 2. Fetching additional instances from https://api.fediverse.observer/
# 3. Fetching additional instances from https://api.fedidb.org/v1.1/software/peertube/servers
# 4. Combining them with existing instances from instances.json
# 5. Deduplicating and saving the result back to instances.json
# 6. Injecting the updated list into PeerTubeScript.js

# Exit on any error
set -e

echo "Updating PeerTube instances..."

# Ensure that required commands are available
command -v curl >/dev/null 2>&1 || { echo "Error: curl is not installed." >&2; exit 1; }
command -v jq >/dev/null 2>&1 || { echo "Error: jq is not installed." >&2; exit 1; }

# Ensure that PeerTubeScript.js ends with exactly one newline
if [ -s PeerTubeScript.js ]; then
    last_char_hex=$(tail -c 1 PeerTubeScript.js | od -An -t x1 | tr -d ' ')
    if [ "$last_char_hex" != "0a" ]; then
        echo >> PeerTubeScript.js
    fi
else
    # If the file is empty, add a newline
    echo >> PeerTubeScript.js
fi

# Define markers
start_marker="// BEGIN AUTOGENERATED INSTANCES"
end_marker="// END AUTOGENERATED INSTANCES"

# Get the current date for autogenerated content
current_date=$(date +%Y-%m-%d)

# Fetch new instances from joinpeertube.org API
echo "Fetching instances from joinpeertube.org API..."
joinpeertube_instances=$(curl -s --max-time 30 "https://instances.joinpeertube.org/api/v1/instances/hosts?start=0&count=10000" | jq -r '.data[].host')

# Check if we fetched valid data from joinpeertube.org
if [ -z "$joinpeertube_instances" ]; then
    echo "Warning: No instances fetched from joinpeertube.org API."
    joinpeertube_instances=""
fi

# Fetch instances from Fediverse Observer API
echo "Fetching instances from Fediverse Observer API..."
fediverse_instances=$(curl -s --max-time 30 'https://api.fediverse.observer/' \
  -X POST \
  -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' \
  --data-raw '{"query":"{nodes(softwarename:\"peertube\" status: \"UP\"){domain}}"}' | \
  jq -r '.data.nodes[].domain')

# Check if we fetched valid data from Fediverse Observer
if [ -z "$fediverse_instances" ]; then
    echo "Warning: No instances fetched from Fediverse Observer API."
    fediverse_instances=""
fi

# Fetch instances from FediDB API using comprehensive approach
echo "Fetching instances from FediDB API..." >&2
fedidb_instances=""

# Function to fetch instances with specific parameters
fetch_fedidb_with_params() {
    local params="$1"
    local description="$2"

    echo "Fetching $description..." >&2

    cursor=""
    page=1
    local_domains=""

    while true; do
        # Build URL
        if [ -z "$cursor" ]; then
            url="https://api.fedidb.org/v1.1/software/peertube/servers?limit=20&$params"
        else
            url="https://api.fedidb.org/v1.1/software/peertube/servers?limit=20&$params&cursor=$cursor"
        fi

        # Fetch page with timeout
        response=$(curl -L -s --max-time 30 "$url")

        # Add delay between requests to be respectful to the API
        sleep 0.3

        # Check if response is valid JSON
        if ! echo "$response" | jq . >/dev/null 2>&1; then
            echo "Warning: Invalid JSON response for $description on page $page" >&2
            break
        fi

        # Extract domains
        page_domains=$(echo "$response" | jq -r '.data[].domain' 2>/dev/null)

        # Check if we got any domains
        if [ -z "$page_domains" ]; then
            break
        fi

        # Add to local domains
        if [ -z "$local_domains" ]; then
            local_domains="$page_domains"
        else
            local_domains="$local_domains
$page_domains"
        fi

        # Get next cursor
        cursor=$(echo "$response" | jq -r '.meta.next_cursor // empty')

        # Break if no more pages
        if [ -z "$cursor" ] || [ "$cursor" = "null" ]; then
            break
        fi

        page=$((page + 1))

        # Safety limit
        if [ $page -gt 50 ]; then
            echo "Warning: Safety limit reached for $description" >&2
            break
        fi
    done

    # Count and report
    local count=$(echo "$local_domains" | grep -c '^' 2>/dev/null || echo "0")
    echo "$description: $count instances" >&2

    # Add to global list
    if [ -n "$local_domains" ]; then
        if [ -z "$fedidb_instances" ]; then
            fedidb_instances="$local_domains"
        else
            fedidb_instances="$fedidb_instances
$local_domains"
        fi
    fi
}

# Track total API calls for reporting
total_api_calls=0

# Generate combinations to maximize data coverage while being respectful to FediDB
# Aim for comprehensive coverage with ~100-200 API calls

# Primary pass: Regional coverage with essential filter combinations
for region in "" "europe" "north-america" "asia" "oceania" "south-america" "africa"; do
    # Use user_count desc for consistent primary sorting
    for filter in "" "registration=open" "version=latest" "mature=1" "small=1" "registration=open&mature=1" "version=latest&registration=open" "version=latest&small=1" "registration=open&mature=1&small=1"; do
        params="sort_by=user_count&sort_direction=desc"

        if [ -n "$region" ]; then
            params="${params}&region=${region}"
        fi

        if [ -n "$filter" ]; then
            params="${params}&${filter}"
        fi

        # Create description
        desc="region=${region:-global}"
        if [ -n "$filter" ]; then
            desc="${desc}, ${filter}"
        fi

        # Increment counter
        total_api_calls=$((total_api_calls + 1))

        # Fetch with these parameters
        fetch_fedidb_with_params "$params" "$desc"
    done
done

# Secondary pass: Different sort orders to catch different data windows
# These may reveal instances not captured by user_count sorting alone
for sort_field in "version" "first_seen_at"; do
    for sort_direction in "desc" "asc"; do
        for filter in "" "registration=open" "version=latest" "mature=1" "small=1"; do
            params="sort_by=${sort_field}&sort_direction=${sort_direction}"

            if [ -n "$filter" ]; then
                params="${params}&${filter}"
            fi

            # Create description
            desc="global, sort=${sort_field}_${sort_direction}"
            if [ -n "$filter" ]; then
                desc="${desc}, ${filter}"
            fi

            # Increment counter
            total_api_calls=$((total_api_calls + 1))

            # Fetch with these parameters
            fetch_fedidb_with_params "$params" "$desc"
        done
    done
done

echo "Total FediDB API filter combinations: $total_api_calls" >&2

# Deduplicate FediDB instances
if [ -n "$fedidb_instances" ]; then
    fedidb_instances=$(echo "$fedidb_instances" | sort -u)
fi

# Check if we fetched valid data from FediDB
if [ -z "$fedidb_instances" ]; then
    echo "Warning: No instances fetched from FediDB API." >&2
    fedidb_instances=""
fi

# Combine instances from all APIs
echo "Combining instances from all APIs..."
new_instances=$(printf "%s\n%s\n%s\n" "$joinpeertube_instances" "$fediverse_instances" "$fedidb_instances" | grep -v '^$')

# Check if we have any new instances
if [ -z "$new_instances" ]; then
    echo "Error: No instances fetched from any API. Aborting update." >&2
    exit 1
fi

# Read existing instances from instances.json
echo "Reading existing instances from instances.json..."
if [ -f "instances.json" ]; then
    existing_instances=$(jq -r '.[]' instances.json 2>/dev/null || echo "")
else
    existing_instances=""
    echo "instances.json not found, starting with empty list"
fi

# Combine and deduplicate instances
echo "Combining and deduplicating instances..."
all_instances=$(printf "%s\n%s\n" "$existing_instances" "$new_instances" | grep -v '^$' | sort -u)

# Check if we have any instances
if [ -z "$all_instances" ]; then
    echo "Error: No instances available after processing. Aborting update." >&2
    exit 1
fi

# Save updated instances to instances.json
echo "Saving updated instances to instances.json..."
echo "$all_instances" | jq -R . | jq -s . > instances.json

# Generate new array content for JavaScript injection
echo "Generating JavaScript content..."
new_array_content=$(echo "$all_instances" | awk -v date="$current_date" -v start_marker="$start_marker" -v end_marker="$end_marker" 'BEGIN {
    print start_marker
    print "// This content is autogenerated during deployment using update-instances.sh"
    print "// Sources: https://instances.joinpeertube.org, https://api.fediverse.observer/, and https://api.fedidb.org/"
    print "// Those hostnames are exclusively used to help the plugin know if a hostname is a PeerTube instance"
    print "// Grayjay nor futo are associated, does not endorse or are responsible for the content in those instances."
    print "// Last updated at: " date
    printf "INDEX_INSTANCES.instances = ["
    first = 1
}
{
    if (!first) printf ","
    printf "\"" $0 "\""
    first = 0
}
END {
    print "];"
    print end_marker
}')

# Remove existing block safely and append new content
temp_file=$(mktemp)
sed "\#$start_marker#,\#$end_marker#d" PeerTubeScript.js > "$temp_file"
echo "$new_array_content" >> "$temp_file"
mv "$temp_file" PeerTubeScript.js

# Print success message
echo "instances.json and PeerTubeScript.js updated successfully"
echo "JoinPeerTube instances: $(echo "$joinpeertube_instances" | grep -c '^')"
echo "Fediverse Observer instances: $(echo "$fediverse_instances" | grep -c '^')"
echo "FediDB instances: $(echo "$fedidb_instances" | grep -c '^')"
echo "Total unique instances: $(echo "$all_instances" | wc -l)"
